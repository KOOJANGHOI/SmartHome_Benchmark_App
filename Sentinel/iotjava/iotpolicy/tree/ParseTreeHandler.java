package iotpolicy.tree;

import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;
import java.io.*;
import iotpolicy.tree.ParseNodeVector;
import iotpolicy.tree.ParseNode;

import java.util.List;
import java.util.ArrayList;

/** Class ParseTreeHandler handles the parse tree generated by the 
 *  parser (and lexer) from the policy file. 
 *  This class accepts the AST in the form of ParseNode and
 *  ParseNodeVector class objects.
 *  It gives interfaces to extract the 4 types of policy file:
 *  1) Interface and capabilities definition
 *  2) Generated interface list ("requires" statements)
 *  3) Enum declaration
 *  4) Struct declaration
 *
 * @author      Rahmadi Trimananda <rahmadi.trimananda @ uci.edu>
 * @version     1.0
 * @since       2016-09-20
 */
public final class ParseTreeHandler {

	/**
	 * Class properties
	 */
	private ParseNode pnPol;		// Policy: interface and capabilities
	private ParseNode pnReq;		// Policy: "requires" statements
	private InterfaceDecl intDecl;
	private CapabilityDecl capDecl;
	private RequiresDecl reqDecl;
	private EnumDecl enumDecl;
	private StructDecl structDecl;


	/**
	 * Class constructors
	 */
	public ParseTreeHandler() {

		pnPol = null;
		pnReq = null;
		intDecl = new InterfaceDecl();
		capDecl = new CapabilityDecl();
		reqDecl = new RequiresDecl();
		enumDecl = new EnumDecl();
		structDecl = new StructDecl();
	}


	public ParseTreeHandler(String _intFace, ParseNode _pnPol, ParseNode _pnReq) {

		pnPol = _pnPol;
		pnReq = _pnReq;
		intDecl = new InterfaceDecl(_intFace);
		capDecl = new CapabilityDecl(_intFace);
		reqDecl = new RequiresDecl(_intFace);
		enumDecl = new EnumDecl();
		structDecl = new StructDecl();
	}


	/**
	 * processInterfaceDecl() processes interface declaration part
	 */
	public void processInterfaceDecl() {

		ParseNodeVector pnv = pnPol.getChildren();
		ParseNode pnRoot = pnv.elementAt(0);
		ParseNodeVector pnvGen2 = pnRoot.getChildren();
		if (pnvGen2.size() == 0) {
			throw new Error("ParseTreeHandler: Interface declaration is missing! Please check your policy file...");
		}
		ParseNode pnGen2 = pnvGen2.elementAt(1);
		ParseNodeVector pnvGen3 = pnGen2.getChildren();
		for(int i = 0; i < pnvGen3.size(); i++) { // Loop on methods

			ParseNode pnGen3 = pnvGen3.elementAt(i);
			ParseNodeVector pnvGen4 = pnGen3.getChildren();
			// Method type, identifier, and param node
			ParseNode pnGen4_type = pnvGen4.elementAt(0);
			ParseNode pnGen4_ident  = pnvGen4.elementAt(1);
			ParseNode pnGen4_params  = pnvGen4.elementAt(2);
			ParseNodeVector pnvGen5 = pnGen4_params.getChildren();
			// First loop - create a key without spaces, e.g. MethodA(intA,SpeakerB)
			String methodKey = pnGen4_ident.getLiteral().toString() + "(";
			List<String> paramTypes = new ArrayList<String>();
			List<String> params = new ArrayList<String>();
			for(int j = 0; j < pnvGen5.size(); j++) { // Loop on params

				ParseNode pnGen5 = pnvGen5.elementAt(j);
				ParseNodeVector pnvGen6 = pnGen5.getChildren();
				// Param type and identifier
				ParseNode pnGen6_type = pnvGen6.elementAt(0);
				ParseNode pnGen6_ident = pnvGen6.elementAt(1);
				methodKey = methodKey + pnGen6_type.getLiteral().toString();
				methodKey = methodKey + pnGen6_ident.getLiteral().toString();
				// Keep the parameters temporarily
				paramTypes.add(pnGen6_type.getLiteral().toString());
				params.add(pnGen6_ident.getLiteral().toString());
				// Don't add comma for the last parameter
				if (j != pnvGen5.size() - 1) {
					methodKey = methodKey + ",";
				}
			}
			methodKey = methodKey + ")";
			// Add a new method (signature key, identifier, and type)
			intDecl.addNewMethod(methodKey, pnGen4_ident.getLiteral().toString(), 
				pnGen4_type.getLiteral().toString());
			// Second loop - add the method parameters
			for(int j = 0; j < params.size(); j++) {
				intDecl.addMethodParam(methodKey, params.get(j), paramTypes.get(j));
			}
		}
	}


	/**
	 * processCapabilityDecl() processes capability declaration part
	 */
	public void processCapabilityDecl() {

		// Get the root - capability list (element 1)
		ParseNodeVector pnv = pnPol.getChildren();
		ParseNode pnRoot = pnv.elementAt(0);
		ParseNodeVector pnvGen2 = pnRoot.getChildren();
		// Get the third child of root for "capab_list"
		ParseNode pnGen2 = pnvGen2.elementAt(2);
		ParseNodeVector pnvGen3 = pnGen2.getChildren();
		if (pnvGen3.size() == 0) {
			throw new Error("ParseTreeHandler: Capability declaration is missing! Please check your policy file...");
		}
		// Iterate over the list of capabilities
		for(int i = 0; i < pnvGen3.size(); i++) {

			ParseNode pnGen3 = pnvGen3.elementAt(i);
			// Get the next level child for capabilities
			ParseNodeVector pnvGen4 = pnGen3.getChildren();
			// Get the capability name, e.g. ImageCapture for Camera.ImageCapture
			ParseNode pnGen4_capab = pnvGen4.elementAt(0);
			// Add new capability
			capDecl.addNewCapability(pnGen4_capab.getLiteral().toString());
			// Get the capability contents, i.e. descriptions and methods
			ParseNode pnGen4_capab_cont = pnvGen4.elementAt(1);
			ParseNodeVector pnvGen5 = pnGen4_capab_cont.getChildren();
			// Iterate over the list of capability contents
			for(int j = 0; j < pnvGen5.size(); j++) {

				ParseNode pnGen5 = pnvGen5.elementAt(j);
				ParseNodeVector pnvGen6 = pnGen5.getChildren();
				ParseNode pnGen6 = pnvGen6.elementAt(0);
				// Check the label and separate between description (capab_desc)
				// and method name (capab_ident)
				String label = pnGen6.getLabel().toString();
				if (label.equals("capab_desc")) {
					capDecl.addNewDescription(pnGen4_capab.getLiteral().toString(),
						pnGen6.getLiteral().toString());
				} else if (label.equals("capab_meth")) {
					capDecl.addNewMethod(pnGen4_capab.getLiteral().toString(),
						pnGen6.getLiteral().toString().replaceAll("\\s+",""));
				} else
					throw new Error("ParseTreeHandler: Unknown label '" + label + "' while operating on parse tree!");

			}
		}
	}


	/**
	 * processRequiresDecl() processes "requires" declaration part
	 */
	public void processRequiresDecl() {

		// Get the root - requires list (element 2)
		ParseNodeVector pnv = pnReq.getChildren();
		ParseNode pnRoot = pnv.elementAt(0);
		// Get the second child of root for "reqlist"
		ParseNodeVector pnvGen2 = pnRoot.getChildren();
		if (pnvGen2.size() == 0) {
			throw new Error("ParseTreeHandler: 'Requires' declaration is missing! Please check your policy file...");
		}
		// Iterate over the list of requires statements
		for(int i = 0; i < pnvGen2.size(); i++) {

			ParseNode pnGen2 = pnvGen2.elementAt(i);
			ParseNodeVector pnvGen3 = pnGen2.getChildren();
			// Get the new interface that we want to generate
			ParseNode pnGen3_intface = pnvGen3.elementAt(2);
			reqDecl.addNewIntface(pnGen3_intface.getLiteral().toString());
			// Get capability list at element 1
			ParseNode pnGen3_capab_list = pnvGen3.elementAt(1);
			ParseNodeVector pnvGen4 = pnGen3_capab_list.getChildren();
			// Browse through capabilities
			for (int j = 0; j < pnvGen4.size(); j++) {
				ParseNode pnGen4 = pnvGen4.elementAt(j);
				reqDecl.addNewCapability(pnGen3_intface.getLiteral().toString(),
					pnGen4.getLiteral().toString());
			}
		}
	}


	/**
	 * processEnumDecl() processes "enum" declaration part
	 */
	public void processEnumDecl() {

		ParseNodeVector pnv = pnPol.getChildren();
		ParseNode pnRoot = pnv.elementAt(0);
		ParseNodeVector pnvGen2 = pnRoot.getChildren();
		// Get the third child of root for "enum"
		ParseNode pnGen2 = pnvGen2.elementAt(3);
		ParseNodeVector pnvGen3 = pnGen2.getChildren();
		// Iterate over a list of enum declaration - can be empty too
		for(int i = 0; i < pnvGen3.size(); i++) {

			ParseNode pnGen4 = pnvGen3.elementAt(i);
			ParseNodeVector pnvGen5 = pnGen4.getChildren();
			// Get the type of the enum
			ParseNode pnGen5_enum_ident = pnvGen5.elementAt(0);
			ParseNode pnGen5_enum_list = pnvGen5.elementAt(1);
			ParseNodeVector pnvGen6_members = pnGen5_enum_list.getChildren();
			// Browse through enum declarations
			for (int j = 0; j < pnvGen6_members.size(); j++) {
				ParseNode pnGen6 = pnvGen6_members.elementAt(j);
				ParseNodeVector pnvGen7 = pnGen6.getChildren();
				ParseNode pnGen7 = pnvGen7.elementAt(0);
				enumDecl.addNewMember(pnGen5_enum_ident.getLiteral().toString(),
					pnGen7.getLiteral().toString());
			}
		}
	}


	/**
	 * processStructDecl() processes "struct" declaration part
	 */
	public void processStructDecl() {

		ParseNodeVector pnv = pnPol.getChildren();
		ParseNode pnRoot = pnv.elementAt(0);
		ParseNodeVector pnvGen2 = pnRoot.getChildren();
		// Get the fourth child of root for "struct"
		ParseNode pnGen2 = pnvGen2.elementAt(4);
		ParseNodeVector pnvGen3 = pnGen2.getChildren();
		// Iterate over a list of struct declaration - can be empty too
		for(int i = 0; i < pnvGen3.size(); i++) {

			ParseNode pnGen4 = pnvGen3.elementAt(i);
			ParseNodeVector pnvGen5 = pnGen4.getChildren();
			// Get the type of the enum
			ParseNode pnGen5_enum_ident = pnvGen5.elementAt(0);
			ParseNode pnGen5_enum_list = pnvGen5.elementAt(1);
			ParseNodeVector pnvGen6_members = pnGen5_enum_list.getChildren();
			// Browse through enum declarations
			for (int j = 0; j < pnvGen6_members.size(); j++) {
				ParseNode pnGen6 = pnvGen6_members.elementAt(j);
				ParseNodeVector pnvGen7 = pnGen6.getChildren();
				ParseNode pnGen7_type = pnvGen7.elementAt(0);
				ParseNode pnGen7_ident = pnvGen7.elementAt(1);
				structDecl.addNewMember(pnGen5_enum_ident.getLiteral().toString(),
					pnGen7_type.getLiteral().toString(), pnGen7_ident.getLiteral().toString());
			}
		}
	}


	/**
	 * getInterfaceDecl() returns InterfaceDecl object
	 */
	public InterfaceDecl getInterfaceDecl() {

		return intDecl;
	}


	/**
	 * getCapabilityDecl() returns CapabilityDecl object
	 */
	public CapabilityDecl getCapabilityDecl() {

		return capDecl;
	}


	/**
	 * getRequiresDecl() returns RequiresDecl object
	 */
	public RequiresDecl getRequiresDecl() {

		return reqDecl;
	}


	/**
	 * getEnumDecl() returns EnumDecl object
	 */
	public EnumDecl getEnumDecl() {

		return enumDecl;
	}


	/**
	 * getStructDecl() returns StructDecl object
	 */
	public StructDecl getStructDecl() {

		return structDecl;
	}


	/**
	 * getOrigIntface() returns the original interface in policy, e.g. Camera
	 * <p>
	 * The ParseNode object should be the one returned from <Parser>.parse().value
	 */
	public static String getOrigIntface(ParseNode pn) {

		// Get the root: just keyword "interface"
		ParseNodeVector pnv = pn.getChildren();
		ParseNode pnRoot = pnv.elementAt(0);
		// Get the child: intface_ident = original interface identifier, e.g. Camera
		ParseNodeVector pnvGen2 = pnRoot.getChildren();
		if (pnvGen2.size() == 0) {
			throw new Error("ParseTreeHandler: Interface declaration is missing! Please check your policy file...");
		}
		// Get "intface_def"
		ParseNode pnGen2 = pnvGen2.elementAt(0);
		// Confirm that this is "intface_ident"
		if (pnGen2.getLabel().equals("intface_ident")) {
			if (pnGen2.getLiteral() != null) {
				return pnGen2.getLiteral().toString();
			} else
				throw new Error("ParseTreeHandler: No interface name found! Please fix policy file!");
		} else
			throw new Error("ParseTreeHandler: Label 'intface_ident' is not found! Instead, '" + pnGen2.getLabel() + "' was found...");
	}
}
